// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

RWStructuredBuffer<float2> _PointColorsPositions;
RWStructuredBuffer<float4> _PointColorsColors;


int _NumColPoints;
int _Width;
int _Height;
bool _OpMode;

struct BorderPoints {
    int pointIndLow;
    int pointIndHigh;
};

// Helper functions

BorderPoints GetColBorderPoints(int currentX) {
    BorderPoints result;
    result.pointIndLow = 0;
    result.pointIndHigh = 0;

    int distanceLowBorder = 2 * _Width;
    int distanceHighBorder = 2 * _Width;

    for (int i = 0; i < _NumColPoints; i++) {
        float2 pos_i = _PointColorsPositions[i];
        int distance = abs((int)pos_i.x - currentX);
        if (pos_i.x <= currentX && distance < distanceLowBorder)
        {
            distanceLowBorder = distance;
            result.pointIndLow = i;
        }
        if (pos_i.x >= currentX && distance < distanceHighBorder)
        {
            distanceHighBorder = distance;
            result.pointIndHigh = i;
        }
    }

    return result;
}

float GetWeight(float2 borderPoint1, float2 borderPoint2, int currentX)
{
    float denominator = abs(borderPoint2.x - borderPoint1.x);
    float nominator = abs((float)currentX - borderPoint1.x);
    if (denominator == 0)
    {
        return 1.0f;
    }
    return nominator / denominator;
}

//src: https://stackoverflow.com/questions/3018313/algorithm-to-convert-rgb-to-hsv-and-hsv-to-rgb-in-range-0-255-for-both
float4  HSV2RGB(float4 _HSV)
{
    _HSV.x = fmod(100.0 + _HSV.x, 1.0);                                       // Ensure [0,1[

    float   HueSlice = 6.0 * _HSV.x;                                            // In [0,6[
    float   HueSliceInteger = floor(HueSlice);
    float   HueSliceInterpolant = HueSlice - HueSliceInteger;                   // In [0,1[ for each hue slice

    float3  TempRGB = float3(_HSV.z * (1.0 - _HSV.y),
        _HSV.z * (1.0 - _HSV.y * HueSliceInterpolant),
        _HSV.z * (1.0 - _HSV.y * (1.0 - HueSliceInterpolant)));

    // The idea here to avoid conditions is to notice that the conversion code can be rewritten:
    //    if      ( var_i == 0 ) { R = V         ; G = TempRGB.z ; B = TempRGB.x }
    //    else if ( var_i == 2 ) { R = TempRGB.x ; G = V         ; B = TempRGB.z }
    //    else if ( var_i == 4 ) { R = TempRGB.z ; G = TempRGB.x ; B = V     }
    // 
    //    else if ( var_i == 1 ) { R = TempRGB.y ; G = V         ; B = TempRGB.x }
    //    else if ( var_i == 3 ) { R = TempRGB.x ; G = TempRGB.y ; B = V     }
    //    else if ( var_i == 5 ) { R = V         ; G = TempRGB.x ; B = TempRGB.y }
    //
    // This shows several things:
    //  . A separation between even and odd slices
    //  . If slices (0,2,4) and (1,3,5) can be rewritten as basically being slices (0,1,2) then
    //      the operation simply amounts to performing a "rotate right" on the RGB components
    //  . The base value to rotate is either (V, B, R) for even slices or (G, V, R) for odd slices
    //
    float   IsOddSlice = fmod(HueSliceInteger, 2.0);                          // 0 if even (slices 0, 2, 4), 1 if odd (slices 1, 3, 5)
    float   ThreeSliceSelector = 0.5 * (HueSliceInteger - IsOddSlice);          // (0, 1, 2) corresponding to slices (0, 2, 4) and (1, 3, 5)

    float3  ScrollingRGBForEvenSlices = float3(_HSV.z, TempRGB.zx);           // (V, Temp Blue, Temp Red) for even slices (0, 2, 4)
    float3  ScrollingRGBForOddSlices = float3(TempRGB.y, _HSV.z, TempRGB.x);  // (Temp Green, V, Temp Red) for odd slices (1, 3, 5)
    float3  ScrollingRGB = lerp(ScrollingRGBForEvenSlices, ScrollingRGBForOddSlices, IsOddSlice);

    float   IsNotFirstSlice = saturate(ThreeSliceSelector);                   // 1 if NOT the first slice (true for slices 1 and 2)
    float   IsNotSecondSlice = saturate(ThreeSliceSelector - 1.0);              // 1 if NOT the first or second slice (true only for slice 2)

    float3 rgb = lerp(ScrollingRGB.xyz, lerp(ScrollingRGB.zxy, ScrollingRGB.yzx, IsNotSecondSlice), IsNotFirstSlice);    // Make the RGB rotate right depending on final slice index
    return float4(rgb.xyz, _HSV.w);
}

float4 GetColInterpolatedColor(BorderPoints bp, int currentX) {
    float weight = GetWeight(_PointColorsPositions[bp.pointIndLow], _PointColorsPositions[bp.pointIndHigh], currentX);
    return HSV2RGB(_PointColorsColors[bp.pointIndLow]) * (1.0f - weight) + HSV2RGB(_PointColorsColors[bp.pointIndHigh]) * weight;
}

float ComputeCrossProduct2D(float2 v1, float2 v2)
{
    return v1.x * v2.y - v1.y * v2.x;
}

bool IsV2OnLeftSideOfV1(float2 v1, float2 v2)
{
    float crossProduct = ComputeCrossProduct2D(v1, v2);
    return crossProduct > 0.0f;
}

bool IsColAboveLine(BorderPoints bp, int currentX, int currentY)
{

    float2 p1 = _PointColorsPositions[bp.pointIndLow];
    float2 p2 = _PointColorsPositions[bp.pointIndHigh];

    // edge case if point1 == point2
    if (bp.pointIndLow == bp.pointIndHigh)
    {
        return currentY <= p1.y;
    }

    float2 p1p2 = p2 - p1;

    float2 curPosVec = float2(currentX, currentY);
    float2 p1CurPosVec = curPosVec - p1;
    return !IsV2OnLeftSideOfV1(p1p2, p1CurPosVec);
}

// END helper functions
[numthreads(16, 16, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{

    BorderPoints bp = GetColBorderPoints(id.x);
    float4 colorOfX = GetColInterpolatedColor(bp, id.x);
    if (!IsColAboveLine(bp, id.x, id.y)) colorOfX = float4(0, 0, 0, 0);
    Result[id.xy] = colorOfX;

    /*if (_OpMode) {
        BorderPoints bp = GetColBorderPoints(id.x);
        float4 colorOfX = GetColInterpolatedColor(bp, id.x);
        if (!IsColAboveLine(bp, id.x, id.y)) colorOfX = float4(0, 0, 0, 0);
        color.w = colorOfX.w;
    }
    else {
        BorderPoints bp = GetColBorderPoints(id.x);
        float4 colorOfX = GetColInterpolatedColor(bp, id.x);
        if (!IsColAboveLine(bp, id.x, id.y)) colorOfX = float4(0, 0, 0, 0);
        color.xyz = colorOfX.xyz;
    }

    Result[id.xy] = color;*/
}


